---
# General notes that apply throughout the file
# * openssl ecparam doesn't directly allow to encrypt the key with passphrase, so we pipe it to encryption command
# * openssl's ec curve "prime256v1" is equivalent to what everyone else calls "secp256r1"

- name: Confirmed required parameters provided
  ansible.builtin.assert:
    that:
      - tas_single_node_base_hostname is defined
      - tas_single_node_base_hostname | trim | length > 0
    msg: "'tas_single_node_base_hostname' must be specified"

- name: Create certificates directory
  ansible.builtin.file:
    state: directory
    dest: "{{ tas_single_node_certs_dir }}"
    mode: "0700"

- name: List files in certs directory
  ansible.builtin.find:
    file_type: file
    paths: "{{ tas_single_node_certs_dir }}"
  register: certs_dir_files

- name: Install openssl for generating RHTAS secrets
  ansible.builtin.package:
    name: openssl
    state: present

- name: Create private key (RSA, 4096 bits)
  ansible.builtin.command:
    cmd: "openssl genrsa -out '{{ tas_single_node_remote_private_key }}' 4096"
    creates: "{{ tas_single_node_remote_private_key }}"
  when: (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_private_key) | list | length) == 0

- name: Create root CA
  when: (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_ca) | list | length) == 0
  block:
    - name: Create certificate signing request (CSR) for CA certificate
      ansible.builtin.command:
        cmd: >-
          openssl req -new -batch
          -key '{{ tas_single_node_remote_private_key }}'
          -subj '/CN={{ tas_single_node_base_hostname }}'
          -addext 'basicConstraints=critical,CA:TRUE'
          -addext 'keyUsage = critical,keyCertSign'
      register: ca_csr
      changed_when: false

    - name: Create self-signed CA certificate from CSR
      ansible.builtin.shell:
        # valid for two years
        cmd: >-
          set -o pipefail &&
          echo "{{ ca_csr.stdout }}" |
          openssl x509 -req -days 730
          -copy_extensions copyall
          -signkey '{{ tas_single_node_remote_private_key }}'
          -out '{{ tas_single_node_remote_ca }}'
        creates: "{{ tas_single_node_remote_ca }}"

- name: Create ingress certificates
  ansible.builtin.include_tasks: create_ingress_cert.yml
  loop:
    - fulcio
    - rekor
    - tuf
    - tsa
    - rekor-search
    - cli-server
  loop_control:
    loop_var: cert_name
  vars:
    existing_files: "{{ certs_dir_files }}"
    remote_ca_key_path: "{{ tas_single_node_remote_private_key }}"
    remote_ca_cert_path: "{{ tas_single_node_remote_ca }}"
    dns_name: "{{ cert_name }}.{{ tas_single_node_base_hostname }}"

- name: Create Fulcio root
  block:
    - name: Load user-provided Fulcio private key
      ansible.builtin.copy:
        content: "{{ tas_single_node_fulcio.private_key }}"
        dest: "{{ tas_single_node_remote_fulcio_user_provided_private_key }}"
        mode: '0644'
      when: tas_single_node_fulcio.private_key is defined and tas_single_node_fulcio.private_key != ""

    - name: Verify if the passphrase matches the user-provided private key
      ansible.builtin.shell:
        cmd: >-
          openssl ec -in '{{ tas_single_node_remote_fulcio_user_provided_private_key }}' -check \
           -passin 'pass:{{ tas_single_node_fulcio.ca_passphrase }}' > /dev/null 2>&1 || echo "failed"
      register: check_key_passphrase
      changed_when: false
      failed_when: check_key_passphrase.stdout == "failed"
      when: tas_single_node_fulcio.private_key is defined and tas_single_node_fulcio.private_key != ""

    - name: Verify if the passphrase matches the auto_generated private key
      ansible.builtin.shell:
        cmd: >-
          openssl ec -in '{{ tas_single_node_remote_fulcio_auto_generated_private_key }}' -check \
           -passin 'pass:{{ tas_single_node_fulcio.ca_passphrase }}' > /dev/null 2>&1 || echo "failed"
      register: check_key_passphrase
      changed_when: false
      when: >
        tas_single_node_fulcio.private_key == ""
        and (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_auto_generated_private_key) | list | length) != 0

    - name: Backup and clean-up old private key
      when: >
          (check_key_passphrase | default({})).stdout is defined
          and check_key_passphrase.stdout == "failed"
      block:
        - name: Back-up old generated private key
          ansible.builtin.copy:
            src: "{{ tas_single_node_remote_fulcio_auto_generated_private_key }}"
            dest: "{{ tas_single_node_remote_fulcio_auto_generated_private_key + '.' + ansible_date_time.iso8601_basic }}"
            remote_src: true
            mode: '0600'

        - name: Clean-up old generated private key
          ansible.builtin.file:
            path: "{{ tas_single_node_remote_fulcio_auto_generated_private_key }}"
            state: absent

    - name: Refresh list of files in certs directory
      ansible.builtin.find:
        file_type: file
        paths: "{{ tas_single_node_certs_dir }}"
      register: certs_dir_files

    - name: Read the old private key content
      ansible.builtin.slurp:
        src: "{{ tas_single_node_remote_fulcio_private_key }}"
      register: old_key_content
      when: (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_private_key) | list | length) != 0

    - name: Read the old root content
      ansible.builtin.slurp:
        src: "{{ tas_single_node_remote_fulcio_root_ca }}"
      register: old_root_content
      when: (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_root_ca) | list | length) != 0

    - name: Backup old fulcio private key and root
      when: >
          (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_private_key) | list | length) != 0
          and
          (old_key_content.content | b64decode != tas_single_node_fulcio.private_key
            or old_root_content.content | b64decode != tas_single_node_fulcio.root_ca)
      block:
        - name: Back-up old provided private key
          ansible.builtin.copy:
            src: "{{ tas_single_node_remote_fulcio_private_key }}"
            dest: "{{ tas_single_node_remote_fulcio_private_key + '.' + ansible_date_time.iso8601_basic }}"
            remote_src: true
            mode: '0600'
          when: >
            old_key_content.content | b64decode != tas_single_node_fulcio.private_key
            and (tas_single_node_fulcio.private_key != ""
              or (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_auto_generated_private_key) | list | length) == 0)

        - name: Back-up old root
          ansible.builtin.copy:
            src: "{{ tas_single_node_remote_fulcio_root_ca }}"
            dest: "{{ tas_single_node_remote_fulcio_root_ca + '.' + ansible_date_time.iso8601_basic }}"
            remote_src: true
            mode: '0600'
          when: >
            old_root_content.content | b64decode != tas_single_node_fulcio.root_ca
            and (tas_single_node_fulcio.private_key != ""
              or (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_auto_generated_private_key) | list | length) == 0)

    - name: Create Fulcio private key
      # NOTE: As of cosign 2.3.0, only RSA with > 2048 B pkey size or ECC with prime256v1 (==secp256r1) are supported
      ansible.builtin.shell:
        cmd: >-
          set -o pipefail &&
          openssl ecparam -genkey -name prime256v1 |
          openssl ec -des3
          -out '{{ tas_single_node_remote_fulcio_auto_generated_private_key }}'
          -passout 'pass:{{ tas_single_node_fulcio.ca_passphrase }}'
        creates: "{{ tas_single_node_remote_fulcio_auto_generated_private_key }}"
      when: >
        tas_single_node_fulcio.private_key is not defined
        or tas_single_node_fulcio.private_key == ""
        and (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_auto_generated_private_key) | list | length) == 0

    - name: Clean-up old tas_single_node_remote_fulcio_user_provided_private_key
      ansible.builtin.file:
        path: "{{ tas_single_node_remote_fulcio_user_provided_private_key }}"
        state: absent
      when: >
        tas_single_node_fulcio.private_key is not defined or tas_single_node_fulcio.private_key == ""
        and (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_user_provided_private_key) | list | length) != 0

    - name: Clean-up old tas_single_node_remote_fulcio_auto_generated_private_key
      ansible.builtin.file:
        path: "{{ tas_single_node_remote_fulcio_auto_generated_private_key }}"
        state: absent
      when: >
        tas_single_node_fulcio.private_key is defined and tas_single_node_fulcio.private_key != ""
        and (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_auto_generated_private_key) | list | length) != 0

    - name: Copy auto-generated Fulcio private key into tas_single_node_remote_fulcio_private_key
      ansible.builtin.copy:
        src: "{{ tas_single_node_remote_fulcio_auto_generated_private_key }}"
        dest: "{{ tas_single_node_remote_fulcio_private_key }}"
        mode: '0600'
        remote_src: true
      when: tas_single_node_fulcio.private_key is not defined or tas_single_node_fulcio.private_key == ""

    - name: Copy user-provided Fulcio private key into tas_single_node_remote_fulcio_private_key
      ansible.builtin.copy:
        src: "{{ tas_single_node_remote_fulcio_user_provided_private_key }}"
        dest: "{{ tas_single_node_remote_fulcio_private_key }}"
        mode: '0600'
        remote_src: true
      when: tas_single_node_fulcio.private_key is defined and tas_single_node_fulcio.private_key != ""

    - name: Verify if public key matches the private key
      ansible.builtin.shell:
        cmd: >-
          set -o pipefail &&
          openssl ec -pubout -in '{{ tas_single_node_remote_fulcio_private_key }}' -passin 'pass:{{ tas_single_node_fulcio.ca_passphrase }}' |
          openssl md5 | awk '{print $NF}' &&
          openssl md5 '{{ tas_single_node_remote_fulcio_public_key }}' | awk '{print $NF}'
      register: public_key_match_check
      changed_when: false
      when: (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_public_key) | list | length) != 0

    - name: Create Fulcio public key
      ansible.builtin.command:
        cmd: >-
          openssl ec -pubout
          -in '{{ tas_single_node_remote_fulcio_private_key }}'
          -out '{{ tas_single_node_remote_fulcio_public_key }}'
          -passin 'pass:{{ tas_single_node_fulcio.ca_passphrase }}'
      changed_when: >
        (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_public_key) | list | length) == 0
        or public_key_match_check.stdout_lines[0] != public_key_match_check.stdout_lines[1]
      when: >
        (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_public_key) | list | length) == 0
        or public_key_match_check.stdout_lines[0] != public_key_match_check.stdout_lines[1]

    - name: Detect private key type
      ansible.builtin.shell:
        cmd: >-
          if grep -q "BEGIN PRIVATE KEY" {{ tas_single_node_remote_fulcio_private_key }}; then
            echo "RSA Key";
          elif grep -q "BEGIN EC PRIVATE KEY" {{ tas_single_node_remote_fulcio_private_key }}; then
            echo "EC Key";
          else
            echo "Unsupported key type";
          fi
      register: key_type_check
      changed_when: false
      failed_when: key_type_check.stdout == "Unsupported key type"

    - name: Load user-provided Fulcio root
      ansible.builtin.copy:
        content: "{{ tas_single_node_fulcio.root_ca }}"
        dest: "{{ tas_single_node_remote_fulcio_root_ca }}"
        mode: '0644'
      when: tas_single_node_fulcio.root_ca is defined and tas_single_node_fulcio.root_ca != ""

    - name: Refresh list of files in certs directory
      ansible.builtin.find:
        file_type: file
        paths: "{{ tas_single_node_certs_dir }}"
      register: certs_dir_files

    - name: Verify if RSA private key matches the certificate
      ansible.builtin.shell:
        cmd: >-
          set -o pipefail &&
          openssl x509 -noout -modulus -in '{{ tas_single_node_remote_fulcio_root_ca }}' | openssl md5 &&
          openssl rsa -noout -modulus -in '{{ tas_single_node_remote_fulcio_private_key }}' -passin 'pass:{{ tas_single_node_fulcio.ca_passphrase }}' |
          openssl md5
      when: >
        key_type_check.stdout == "RSA Key"
        and (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_root_ca) | list | length) != 0
      register: rsa_key_cert_match_check
      changed_when: false

    - name: Verify if EC private key matches the certificate
      ansible.builtin.shell:
        cmd: >-
          set -o pipefail &&
          openssl x509 -pubkey -noout -in '{{ tas_single_node_remote_fulcio_root_ca }}' |
          openssl pkey -pubin -outform pem | openssl md5 &&
          openssl ec -pubout -in '{{ tas_single_node_remote_fulcio_private_key }}' -passin 'pass:{{ tas_single_node_fulcio.ca_passphrase }}' |
          openssl md5
      when: >
        key_type_check.stdout == "EC Key"
        and (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_root_ca) | list | length) != 0
      register: ec_key_cert_match_check
      changed_when: false

    - name: Set default value for key_cert_mismatch
      ansible.builtin.set_fact:
        key_cert_mismatch: false

    - name: Verify if private key and certificate mismatch
      ansible.builtin.set_fact:
        key_cert_mismatch: >-
          {{
            (key_type_check.stdout == "RSA Key" and
            rsa_key_cert_match_check is defined and
            rsa_key_cert_match_check.stdout_lines is defined and
            rsa_key_cert_match_check.stdout_lines[0].strip() != rsa_key_cert_match_check.stdout_lines[1].strip())
            or
            (key_type_check.stdout == "EC Key" and
            ec_key_cert_match_check is defined and
            ec_key_cert_match_check.stdout_lines is defined and
            ec_key_cert_match_check.stdout_lines[0].strip() != ec_key_cert_match_check.stdout_lines[1].strip())
          }}
      failed_when: key_cert_mismatch and tas_single_node_fulcio.root_ca != ""
      when: (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_root_ca) | list | length) != 0

    - name: Set default value for cert_changed
      ansible.builtin.set_fact:
        cert_changed: false

    - name: Get current certificate subject details
      ansible.builtin.command:
        cmd: openssl x509 -in '{{ tas_single_node_remote_fulcio_root_ca }}' -noout -text
      register: current_cert_subject
      changed_when: false
      when: (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_root_ca) | list | length) != 0

    - name: Check if fulcio certificate needs to be regenerated
      ansible.builtin.set_fact:
        cert_changed: "{{
          (current_cert_subject.stdout | default('') | regex_search('Subject: O = ([^\\n]+)', '\\1') or ['']) | first
          != tas_single_node_fulcio.certificate.organization_name
          or
          (current_cert_subject.stdout | default('') | regex_search('Subject: CN = ([^\\n]+)', '\\1') or ['']) | first
          != tas_single_node_fulcio.certificate.common_name
          or
          (current_cert_subject.stdout | default('') | regex_search('Subject: emailAddress = ([^\\n]+)', '\\1') or ['']) | first
          != tas_single_node_fulcio.certificate.organization_email }}"
      when: tas_single_node_fulcio.root_ca is not defined or tas_single_node_fulcio.root_ca == ""

    - name: Create certificate signing request (CSR) for Fulcio root certificate
      ansible.builtin.command:
        cmd: >-
          openssl req -new -batch
          -key '{{ tas_single_node_remote_fulcio_private_key }}'
          {{ " -subj '/O=" ~ tas_single_node_fulcio.certificate.organization_name ~
            "/CN=" ~ tas_single_node_fulcio.certificate.common_name ~
            "/emailAddress=" ~ tas_single_node_fulcio.certificate.organization_email ~ "'" }}
          -addext 'basicConstraints=critical,CA:TRUE'
          -addext 'keyUsage = critical,keyCertSign'
          -passin 'pass:{{ tas_single_node_fulcio.ca_passphrase }}'
      register: fulcio_root_csr
      changed_when: false
      when: >
        cert_changed or
        (tas_single_node_fulcio.root_ca is not defined or tas_single_node_fulcio.root_ca == "")
        and (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_root_ca) | list | length) == 0
        or key_cert_mismatch

    - name: Backup and clean-up old Fulcio root
      when: cert_changed
      block:
        - name: Back-up old Fulcio root
          ansible.builtin.copy:
            src: "{{ tas_single_node_remote_fulcio_root_ca }}"
            dest: "{{ tas_single_node_remote_fulcio_root_ca + '.' + ansible_date_time.iso8601_basic }}"
            remote_src: true
            mode: '0644'

        - name: Clean-up old Fulcio root
          ansible.builtin.file:
            path: "{{ tas_single_node_remote_fulcio_root_ca }}"
            state: absent

    - name: Refresh list of files in certs directory
      ansible.builtin.find:
        file_type: file
        paths: "{{ tas_single_node_certs_dir }}"
      register: certs_dir_files

    - name: Create self-signed Fulcio root from CSR
      ansible.builtin.shell:
        # valid for two years
        cmd: >-
          set -o pipefail &&
          echo "{{ fulcio_root_csr.stdout }}" |
          openssl x509 -req -days 730
          -copy_extensions copyall
          -signkey '{{ tas_single_node_remote_fulcio_private_key }}'
          -passin 'pass:{{ tas_single_node_fulcio.ca_passphrase }}'
          -out '{{ tas_single_node_remote_fulcio_root_ca }}'
      changed_when: >
        (tas_single_node_fulcio.root_ca is not defined or tas_single_node_fulcio.root_ca == "")
        and (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_root_ca) | list | length) == 0
        or key_cert_mismatch
      when: >
        (tas_single_node_fulcio.root_ca is not defined or tas_single_node_fulcio.root_ca == "")
        and (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_fulcio_root_ca) | list | length) == 0
        or key_cert_mismatch

# Back-up ctlog private keys
- name: Get existing ctlog private keys
  block:
    - name: Find existing ctlog private key files
      ansible.builtin.find:
        paths: "{{ tas_single_node_certs_dir }}"
        patterns: "ctlog*.key"
      register: existing_ctlog_keys

    - name: Read existing ctlog private key files
      ansible.builtin.slurp:
        src: "{{ item.path }}"
      loop: "{{ existing_ctlog_keys.files }}"
      register: existing_keys

- name: Set ctlog_private_keys_changed
  ansible.builtin.set_fact:
    ctlog_private_keys_changed: >-
      {{ (existing_keys.results | length != tas_single_node_ctlog.private_keys | length
      or (existing_keys.results | map(attribute='content') | map('b64decode') | list) != tas_single_node_ctlog.private_keys)
      and (tas_single_node_ctlog.private_keys | length > 0
        or (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_certs_dir + '/_ctlog_use_provided_root') | list | length != 0)) }}

- name: Back-up changed ctlog private keys
  when: existing_keys.results | length > 0 and ctlog_private_keys_changed
  block:
    - name: Identify private keys that need back-up
      ansible.builtin.set_fact:
        keys_to_backup: >-
          {{ existing_keys.results |
            selectattr('content', 'defined') |
            map(attribute='content') |
            map('b64decode') |
            zip(existing_keys.results | map(attribute='source')) |
            rejectattr(0, 'in', tas_single_node_ctlog.private_keys) |
            map(attribute=1) |
            list }}

    - name: Back-up old ctlog private keys
      ansible.builtin.copy:
        src: "{{ item }}"
        dest: "{{ item + '.' + ansible_date_time.iso8601_basic }}"
        remote_src: true
        mode: '0600'
      loop: "{{ keys_to_backup }}"

    - name: Clean-up old ctlog private keys
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop: "{{ keys_to_backup }}"

# Back-up ctlog public keys
- name: Get existing ctlog public keys
  block:
    - name: Find existing ctlog public key files
      ansible.builtin.find:
        paths: "{{ tas_single_node_certs_dir }}"
        patterns: "ctlog*.pub"
      register: existing_ctlog_keys

    - name: Read existing ctlog public key files
      ansible.builtin.slurp:
        src: "{{ item.path }}"
      loop: "{{ existing_ctlog_keys.files }}"
      register: existing_keys

- name: Set ctlog_public_keys_changed
  ansible.builtin.set_fact:
    ctlog_public_keys_changed: >-
      {{ (existing_keys.results | length != tas_single_node_ctlog.public_keys | length
      or (existing_keys.results | map(attribute='content') | map('b64decode') | list) != tas_single_node_ctlog.public_keys)
      and (tas_single_node_ctlog.public_keys | length > 0
        or (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_certs_dir + '/_ctlog_use_provided_root') | list | length != 0)) }}

- name: Back-up changed ctlog public keys
  when: existing_keys.results | length > 0 and ctlog_public_keys_changed
  block:
    - name: Identify public keys that need back-up
      ansible.builtin.set_fact:
        keys_to_backup: >-
          {{ existing_keys.results |
            selectattr('content', 'defined') |
            map(attribute='content') |
            map('b64decode') |
            zip(existing_keys.results | map(attribute='source')) |
            rejectattr(0, 'in', tas_single_node_ctlog.public_keys) |
            map(attribute=1) |
            list }}

    - name: Back-up old ctlog public keys
      ansible.builtin.copy:
        src: "{{ item }}"
        dest: "{{ item + '.' + ansible_date_time.iso8601_basic }}"
        remote_src: true
        mode: '0600'
      loop: "{{ keys_to_backup }}"

    - name: Clean-up old ctlog public keys
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop: "{{ keys_to_backup }}"

- name: Create Custom ctlog Root
  when: >
    (tas_single_node_ctlog.public_keys | length > 0) and (tas_single_node_ctlog.private_keys | length > 0)
  no_log: true
  block:
    - name: Create marker file if keys are provided by the user
      ansible.builtin.file:
        path: "{{ tas_single_node_certs_dir }}/_ctlog_use_provided_root"
        state: touch
        mode: '0644'
      when: certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_certs_dir + '/_ctlog_use_provided_root') | list | length == 0

    - name: Create custom ctlog private keys
      when: ctlog_private_keys_changed
      changed_when: false
      ansible.builtin.copy:
        content: "{{ key_var }}"
        dest: "{{ tas_single_node_certs_dir }}/ctlog{{ key_num }}.key"
        mode: '0600'
      loop: '{{ tas_single_node_ctlog.private_keys | list }}'
      loop_control:
        loop_var: key_var
        index_var: key_num

    - name: Reset ctlog Private Key path list
      ansible.builtin.set_fact:
        tas_single_node_remote_ctlog_private_key: []

    - name: Track ctlog private keys
      when: key_var != ""
      changed_when: false
      loop: '{{ tas_single_node_ctlog.private_keys | list }}'
      loop_control:
        index_var: key_num
        loop_var: key_var
      ansible.builtin.set_fact:
        tas_single_node_remote_ctlog_private_key: >
          {{ tas_single_node_remote_ctlog_private_key + [tas_single_node_certs_dir ~'/ctlog' ~ key_num ~ '.key'] }}

    # Clean-up extra ctlog private keys.
    # If tas_single_node_ctlog.private_keys shrinks, remove outdated keys.
    # Example: If initial keys were [ctlog0, ctlog1] and ctlog0 is removed,
    # ctlog0 is backed up, ctlog1 becomes the new ctlog0, and old ctlog1 is deleted.
    - name: Find all existing ctlog private key files
      ansible.builtin.find:
        paths: "{{ tas_single_node_certs_dir }}"
        patterns: "ctlog*.key"
      register: remaining_ctlog_keys

    - name: Identify extra ctlog private keys to remove
      ansible.builtin.set_fact:
        extra_keys_to_remove: >-
          {{ remaining_ctlog_keys.files |
             map(attribute='path') |
             difference(tas_single_node_remote_ctlog_private_key) }}

    - name: Remove extra ctlog private keys
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop: "{{ extra_keys_to_remove }}"
      when: extra_keys_to_remove | length > 0

    - name: Create custom ctlog public key
      when: ctlog_public_keys_changed
      changed_when: false
      ansible.builtin.copy:
        content: "{{ key_var }}"
        dest: "{{ tas_single_node_certs_dir }}/ctlog{{ key_num }}.pub"
        mode: '0600'
      loop: '{{ tas_single_node_ctlog.public_keys | list }}'
      loop_control:
        loop_var: key_var
        index_var: key_num

    - name: Reset ctlog public key path
      ansible.builtin.set_fact:
        tas_single_node_remote_ctlog_public_key: []

    - name: Track ctlog Public Keys
      when: key_var != ""
      changed_when: false
      loop: '{{ tas_single_node_ctlog.public_keys | list }}'
      loop_control:
        index_var: key_num
        loop_var: key_var
      ansible.builtin.set_fact:
        tas_single_node_remote_ctlog_public_key: >
          {{ tas_single_node_remote_ctlog_public_key + [tas_single_node_certs_dir ~'/ctlog' ~ key_num ~ '.pub']}}

    # Clean-up extra ctlog public keys.
    - name: Find all existing ctlog public key files
      ansible.builtin.find:
        paths: "{{ tas_single_node_certs_dir }}"
        patterns: "ctlog*.pub"
      register: remaining_ctlog_keys

    - name: Identify extra ctlog public keys to remove
      ansible.builtin.set_fact:
        extra_keys_to_remove: >-
          {{ remaining_ctlog_keys.files |
             map(attribute='path') |
             difference(tas_single_node_remote_ctlog_public_key) }}

    - name: Remove extra ctlog public keys
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop: "{{ extra_keys_to_remove }}"
      when: extra_keys_to_remove | length > 0

- name: Refresh list of files in certs directory
  ansible.builtin.find:
    file_type: file
    paths: "{{ tas_single_node_certs_dir }}"
  register: certs_dir_files

- name: Generate ctlog root
  when: >
    ((certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_ctlog_private_key.0) | list | length) == 0
    or (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_ctlog_public_key.0) | list | length) == 0)
    and ( tas_single_node_ctlog.public_keys | length == 0 ) and (tas_single_node_ctlog.private_keys | length == 0 )
  block:
    - name: Remove marker file if no keys are provided by the user
      ansible.builtin.file:
        path: "{{ tas_single_node_certs_dir }}/_ctlog_use_provided_root"
        state: absent
      when: certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_certs_dir + '/_ctlog_use_provided_root') | list | length != 0

    - name: Create ctlog private key
      ansible.builtin.shell:
        cmd: >-
          set -o pipefail &&
          openssl ecparam -genkey -name prime256v1 |
          openssl ec -des3
          -out '{{ tas_single_node_remote_ctlog_private_key.0 }}'
          -passout 'pass:{{ tas_single_node_ctlog.ca_passphrase }}'
        creates: "{{ tas_single_node_remote_ctlog_private_key.0 }}"
    - name: Create ctlog public key
      ansible.builtin.command:
        cmd: >-
          openssl ec -pubout
          -in '{{ tas_single_node_remote_ctlog_private_key.0 }}'
          -out '{{ tas_single_node_remote_ctlog_public_key.0 }}'
          -passin 'pass:{{ tas_single_node_ctlog.ca_passphrase }}'
        creates: "{{ tas_single_node_remote_ctlog_public_key.0 }}"

- name: Create Rekor signing key
  when: >
    (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_rekor_private_key) | list | length) == 0
    or (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_rekor_public_key) | list | length) == 0
    and tas_single_node_rekor_signer_type == 'file'

  block:
    - name: Create Rekor private key
      ansible.builtin.shell:
        cmd: >-
          set -o pipefail &&
          openssl ecparam -genkey -name prime256v1 |
          openssl ec -des3
          -out '{{ tas_single_node_remote_rekor_private_key }}'
          -passout 'pass:{{ tas_single_node_rekor.ca_passphrase }}'
        creates: "{{ tas_single_node_remote_rekor_private_key }}"
    - name: Create Rekor public key
      ansible.builtin.command:
        cmd: >-
          openssl ec -pubout
          -in '{{ tas_single_node_remote_rekor_private_key }}'
          -out '{{ tas_single_node_remote_rekor_public_key }}'
          -passin 'pass:{{ tas_single_node_rekor.ca_passphrase }}'
        creates: "{{ tas_single_node_remote_rekor_public_key }}"

- name: Handle TSA certificate chain
  when: >
    tas_single_node_tsa.signer_private_key == ''
    and tas_single_node_tsa.certificate_chain == ''
    and tas_single_node_tsa.signer_type == 'file'
  block:
    - name: Verify if the passphrase matches the existing private key
      ansible.builtin.shell:
        cmd: >-
          openssl ec -in '{{ tas_single_node_remote_tsa_private_key }}' -check \
           -passin 'pass:{{ tas_single_node_tsa.ca_passphrase }}' > /dev/null 2>&1 || echo "failed"
      register: tsa_key_passphrase
      changed_when: false
      when: (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_tsa_private_key) | list | length) != 0

    - name: Get current certificate subject details
      ansible.builtin.command:
        cmd: openssl x509 -in '{{ tas_single_node_tsa_certificate_chain }}' -noout -text
      register: current_cert_subject
      changed_when: false
      when: (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) != 0

    - name: Set cert_needs_regeneration flag
      ansible.builtin.set_fact:
        cert_needs_regeneration: "{{
          (current_cert_subject.stdout | regex_search('O = ([^,\n]+)', '\\1'))[0] | default('')
          != tas_single_node_tsa.certificate.organization_name
          or
          (current_cert_subject.stdout | regex_search('^.*Issuer:.*$', multiline=True) | regex_search('CN = ([^,\n]+)', '\\1'))[0] | default('')
          != tas_single_node_tsa.certificate.common_name
          or
          (current_cert_subject.stdout | regex_search('emailAddress = ([^\"\n]+)', '\\1'))[0] | default('')
          != tas_single_node_tsa.certificate.organization_email }}"
      when: (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) != 0

    - name: Back-up and Clean up generated keys and certs
      when: (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) != 0 and
            (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_tsa_private_key) | list | length) != 0 and
            (cert_needs_regeneration or ((tsa_key_passphrase | default({})).stdout is defined and tsa_key_passphrase.stdout == "failed"))
      block:
        - name: Back-up old generated certs and keys
          ansible.builtin.copy:
            src: "{{ item }}"
            dest: "{{ item + '.' + ansible_date_time.iso8601_basic }}"
            remote_src: true
            mode: '0600'
          with_items:
            - "{{ tas_single_node_tsa_certificate_chain }}"
            - "{{ tas_single_node_tsa_signer_private_key }}"
            - "{{ tas_single_node_remote_tsa_private_key }}"
            - "{{ tas_single_node_remote_tsa_leaf_certificate }}"

        - name: Delete old certificates if configuration has changed
          ansible.builtin.file:
            path: "{{ item }}"
            state: absent
          with_items:
            - "{{ tas_single_node_tsa_certificate_chain }}"
            - "{{ tas_single_node_tsa_signer_private_key }}"
            - "{{ tas_single_node_remote_tsa_private_key }}"
            - "{{ tas_single_node_remote_tsa_leaf_certificate }}"

    - name: Refresh list of files in certs directory
      ansible.builtin.find:
        file_type: file
        paths: "{{ tas_single_node_certs_dir }}"
      register: certs_dir_files

    - name: Create TSA root private key
      ansible.builtin.shell:
        cmd: >-
          set -o pipefail &&
          openssl ecparam -genkey -name prime256v1 |
          openssl ec -des3
          -out '{{ tas_single_node_remote_tsa_private_key }}'
          -passout 'pass:{{ tas_single_node_tsa.ca_passphrase }}'
        creates: "{{ tas_single_node_remote_tsa_private_key }}"
      when: >
        (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_remote_tsa_private_key) | list | length) == 0
        and (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) == 0

    - name: Create certificate signing request (CSR) for TSA root certificate
      ansible.builtin.command:
        cmd: >-
          openssl req -new -batch
          -key '{{ tas_single_node_remote_tsa_private_key }}'
          {{ " -subj '/O=" ~ tas_single_node_tsa.certificate.organization_name ~
            "/CN=" ~ tas_single_node_tsa.certificate.common_name ~
            "/emailAddress=" ~ tas_single_node_tsa.certificate.organization_email ~ "'" }}
          -addext 'basicConstraints=critical,CA:TRUE'
          -addext 'keyUsage = keyCertSign'
          -passin 'pass:{{ tas_single_node_tsa.ca_passphrase }}'
      register: tsa_root_csr
      when: >
        (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) == 0
      changed_when: false

    - name: Create self-signed TSA root CA from CSR
      ansible.builtin.shell:
        # valid for two years
        cmd: >-
          set -o pipefail &&
          echo "{{ tsa_root_csr.stdout }}" |
          openssl x509 -req -days 730
          -copy_extensions copyall
          -signkey '{{ tas_single_node_remote_tsa_private_key }}'
          -passin 'pass:{{ tas_single_node_tsa.ca_passphrase }}'
          -out '{{ tas_single_node_tsa_certificate_chain }}'
        creates: "{{ tas_single_node_tsa_certificate_chain }}"
      when: >
        (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) == 0

    # Leaf certificate
    - name: Create TSA leaf CA private key
      ansible.builtin.shell:
        cmd: >-
          set -o pipefail &&
          openssl ecparam -genkey -name prime256v1 |
          openssl ec -des3
          -out '{{ tas_single_node_tsa_signer_private_key }}'
          -passout 'pass:{{ tas_single_node_tsa.signer_passphrase }}'
        creates: "{{ tas_single_node_tsa_signer_private_key }}"
      when: >
        (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) == 0
        and (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_signer_private_key) | list | length) == 0

    - name: Create TSA leaf CSR
      ansible.builtin.command:
        cmd: >-
          openssl req -new -batch
          -key '{{ tas_single_node_tsa_signer_private_key }}'
          -subj '/CN=TSA Leaf certificate'
          -addext 'basicConstraints=critical,CA:FALSE'
          -addext 'keyUsage = critical,digitalSignature'
          -addext 'extendedKeyUsage = critical,timeStamping'
          -passin 'pass:{{ tas_single_node_tsa.signer_passphrase }}'
      register: tsa_leaf_csr
      when: >
        (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) == 0
      changed_when: false

    - name: Sign leaf certificate with Root CA
      ansible.builtin.shell:
        # valid for two years
        cmd: >-
          set -o pipefail &&
          echo "{{ tsa_leaf_csr.stdout }}" |
          openssl x509 -req -days 730
          -copy_extensions copyall
          -CA '{{ tas_single_node_tsa_certificate_chain }}'
          -CAkey '{{ tas_single_node_remote_tsa_private_key }}'
          -passin 'pass:{{ tas_single_node_tsa.ca_passphrase }}'
          -out '{{ tas_single_node_remote_tsa_leaf_certificate }}'
        creates: "{{ tas_single_node_remote_tsa_leaf_certificate }}"
      when: >
        (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) == 0

    - name: Slurp the leaf certificate
      ansible.builtin.slurp:
        src: "{{ tas_single_node_remote_tsa_leaf_certificate }}"
      register: leaf_cert
      when: >
        (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) == 0

    - name: Slurp the root CA certificates
      ansible.builtin.slurp:
        src: "{{ tas_single_node_tsa_certificate_chain }}"
      register: root_cert
      when: >
        (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) == 0

    - name: Combine leaf and root CA certificates into a chain
      ansible.builtin.copy:
        content: "{{ leaf_cert.content | b64decode }}\n{{ root_cert.content | b64decode }}"
        dest: "{{ tas_single_node_tsa_certificate_chain }}"
        mode: '600'
      when: >
        (certs_dir_files.files | selectattr('path', 'equalto', tas_single_node_tsa_certificate_chain) | list | length) == 0

- name: Handle user provided TSA cert chain and private key
  block:
    - name: Fail if certificate chain is provided, but private signer key is not
      ansible.builtin.fail:
        msg: "For signer type 'file', if certificate_chain is provide then the signer_private_key must also be provided."
      when:
        - tas_single_node_tsa.signer_type == 'file'
        - tas_single_node_tsa.certificate_chain | length > 0
        - tas_single_node_tsa.signer_private_key | length == 0

    - name: Fail if signer private key is provided, but certificate chain is not
      ansible.builtin.fail:
        msg: "For signer type 'file', if signer_private_key is provided then the certificate_chain must also be provided."
      when:
        - tas_single_node_tsa.signer_type == 'file'
        - tas_single_node_tsa.certificate_chain | length == 0
        - tas_single_node_tsa.signer_private_key | length > 0

    - name: Set user provided certificate chain
      ansible.builtin.copy:
        content: "{{ tas_single_node_tsa.certificate_chain }}"
        dest: "{{ tas_single_node_tsa_certificate_chain }}"
        mode: '0600'
      when: tas_single_node_tsa.certificate_chain != ''

    - name: Set user provided private key
      ansible.builtin.copy:
        content: "{{ tas_single_node_tsa.signer_private_key }}"
        dest: "{{ tas_single_node_tsa_signer_private_key }}"
        mode: '600'
      when: >
        tas_single_node_tsa.signer_private_key != ''
        and tas_single_node_tsa.signer_type == 'file'

    - name: Verify if the passphrase matches the existing private key
      ansible.builtin.shell:
        cmd: >-
          openssl ec -in '{{ tas_single_node_tsa_signer_private_key }}' -check \
           -passin 'pass:{{ tas_single_node_tsa.ca_passphrase }}' > /dev/null 2>&1 || echo "failed"
      register: tsa_key_passphrase
      changed_when: false
      failed_when: tsa_key_passphrase.stdout == "failed"
      when: tas_single_node_tsa.signer_private_key is defined and tas_single_node_tsa.signer_private_key != ""
